type Activity {
  archiveContentType: String
  archiveFilename: String
  archiveId: String
  archiveSize: Int
  createdAt: ISO8601DateTime!
  deletedAt: ISO8601DateTime
  evidenceText: String
  id: ID!
  justify: String
  portalUserId: Int
  projectId: Int
  status: String
  title: String
  updatedAt: ISO8601DateTime!
}

type Analysis {
  activeObeo: Boolean
  activitieCompleted: Int
  activities: [Activity!]!
  apiCode: String
  apiResponseReview: String
  applicant: String
  applicantArea: String
  auditing: String
  closeComments: Boolean
  connectivity: String
  continuousDelivery: Boolean
  contractedHours: Int
  createdAt: ISO8601DateTime
  deploySendFrequency: Int
  description: String
  dueDate: ISO8601DateTime
  endDate: ISO8601DateTime
  environmentInvaded: Boolean
  estimatedDays: String
  estimatedHours: String
  executiveSummary: String
  freeRetest: Boolean
  hasOpenRetest: Boolean
  hoursOrDays: String
  id: ID!
  integrationDeploy: Boolean
  inviteToken: String
  isOpen: Boolean!
  isPublic: Boolean
  label: String!
  language: String
  lastProjectStatusId: Int
  mainRecommendations: String
  microserviceFolder: String
  notificationList: String
  notifications: [Notification!]!
  pid: String
  planId: Int
  plannedStartedAt: ISO8601DateTime
  playbooks: [Playbook!]!
  projectStatusId: Int
  projectTypeId: Int!
  receiveDeploys: Boolean
  repositoryUrl: String
  retestedAt: ISO8601DateTime
  sacCode: String
  sacProjectId: Int
  scopeId: Int!
  secretId: String
  sshPublicKey: String
  startDate: ISO8601DateTime!
  students: Int
  subScopeId: Int
  totalAnalysisLines: Int
  totalChangedLines: Int
  totalNewLines: Int
  totalPublishedVulnerabilities: Int
  totalRemovedLines: Int
  updatedAt: ISO8601DateTime
  userableId: Int
  userableType: String
  vulnerabilities: [Vulnerability!]!
  waiting: Boolean!
}

type AnalysisCollection {
  collection: [Analysis!]!
  metadata: CollectionMetadata!
}

type Asset {
  applicationIdGauntlet: Int
  architectureType: String
  assetType: String
  assetsTagList: String
  audience: String
  createdAt: ISO8601DateTime!
  criticity: String
  dataClassification: String
  description: String
  developmentModel: String
  developmentTeam: String
  environment: String
  errorGauntlet: String
  id: ID!
  lifeCycle: String
  name: String
  scanType: String
  scopeId: Int
  updatedAt: ISO8601DateTime!
  url: String
  verificationTokenGauntlet: String
  verifyStatusGauntlet: String
}

type AssetCollection {
  collection: [Asset!]!
  metadata: CollectionMetadata!
}

type CollectionMetadata {
  currentPage: Int!
  limitValue: Int!
  totalCount: Int!
  totalPages: Int!
}

"""
Autogenerated input type of CreateNotification
"""
input CreateNotificationInput {
  analysisId: Int!
  vulnerabilityTemplateId: Int!
  description: String!
  evidenceArchives: [Upload!]!

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
}

"""
Autogenerated return type of CreateNotification
"""
type CreateNotificationPayload {
  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  errors: [String!]
  notification: Vulnerability
}

"""
Autogenerated input type of CreateWebVulnerability
"""
input CreateWebVulnerabilityInput {
  analysisId: Int!
  vulnerabilityTemplateId: Int!

  """
  Possible options [low, medium or high]
  """
  impact: String!

  """
  Possible options [low, medium or high]
  """
  probability: String!
  description: String!
  impactResume: String!
  webProtocol: String!

  """
  Possible options [GET, POST, DELETE, PUT, PATCH, HEAD, CONNECT, OPTIONS, TRACE]
  """
  webMethod: String!
  webParameters: String!
  webUrl: String!
  webSteps: String!
  webRequest: String!
  webResponse: String!
  invaded: Boolean!

  """
  Required only if invaded true
  """
  invadedEnvironmentDescription: String
  evidenceArchives: [Upload!]!

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
}

"""
Autogenerated return type of CreateWebVulnerability
"""
type CreateWebVulnerabilityPayload {
  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  errors: [String!]
  vulnerability: Vulnerability
}

type Deploy {
  aasmState: String
  createdAt: ISO8601DateTime!
  currentCommit: String
  currentTag: String
  deployUrlCompare: String
  discardReason: String
  discardedId: Int
  gauntletDiffUrl: String
  gauntletScanId: Int
  gauntletSourceCodeId: Int
  id: ID!
  previousCommit: String
  previousTag: String
  projectId: Int
  reviewed: Boolean
  reviewedAt: ISO8601DateTime
  reviewerId: Int
  updatedAt: ISO8601DateTime!
}

"""
An ISO 8601-encoded date
"""
scalar ISO8601Date

"""
An ISO 8601-encoded datetime
"""
scalar ISO8601DateTime

type Mutation {
  """
  Create a Notification
  """
  createNotification(
    """
    Parameters for CreateNotification
    """
    input: CreateNotificationInput!
  ): CreateNotificationPayload

  """
  Create a Web Vulnerability
  """
  createWebVulnerability(
    """
    Parameters for CreateWebVulnerability
    """
    input: CreateWebVulnerabilityInput!
  ): CreateWebVulnerabilityPayload

  """
  Update activity status to finish
  """
  updateActivityStatusToFinish(
    """
    Parameters for UpdateActivityStatusToFinish
    """
    input: UpdateActivityStatusToFinishInput!
  ): UpdateActivityStatusToFinishPayload

  """
  Update activity status to not apply
  """
  updateActivityStatusToNotApply(
    """
    Parameters for UpdateActivityStatusToNotApply
    """
    input: UpdateActivityStatusToNotApplyInput!
  ): UpdateActivityStatusToNotApplyPayload

  """
  Update activity status to restart
  """
  updateActivityStatusToRestart(
    """
    Parameters for UpdateActivityStatusToRestart
    """
    input: UpdateActivityStatusToRestartInput!
  ): UpdateActivityStatusToRestartPayload

  """
  Update activity status to start
  """
  updateActivityStatusToStart(
    """
    Parameters for UpdateActivityStatusToStart
    """
    input: UpdateActivityStatusToStartInput!
  ): UpdateActivityStatusToStartPayload
}

type Notification {
  analysesId: Int
  authorId: Int
  createdAt: ISO8601DateTime!
  description: String
  id: ID!
  notificationStatus: String
  updatedAt: ISO8601DateTime!
  vulnerabilityTemplateId: Int
}

type NotificationCollection {
  collection: [Notification!]!
  metadata: CollectionMetadata!
}

type Playbook {
  checklistTypeId: Int
  createdAt: ISO8601DateTime
  deletedAt: ISO8601DateTime
  description: String
  id: ID!
  label: String!
  scopeId: Int
  updatedAt: ISO8601DateTime
}

type PortalUser {
  allocatedAnalyses: [Analysis!]!
  analyst: Boolean
  blocked: Boolean
  dashboardOnly: Boolean
  email: String!
  endWorkTime: String
  financial: Boolean
  githubUser: String
  history: String!
  id: ID!
  jiraUser: String
  name: String
  oper: Boolean
  phone: String
  reviews: [Deploy!]!
  slackUser: String
  sshKeys: String
  vulnerabilities: [Vulnerability!]!
}

type Project {
  analysis: [Analysis!]!
  beginDate: ISO8601Date
  conclusion: String
  contractId: Int
  createdAt: ISO8601DateTime!
  endDate: ISO8601Date
  id: ID!
  kickoff: Boolean
  name: String
  planStatus: String
  presential: Boolean
  projectDescription: String
  scopeId: Int
  sumTotalAnalysisLines: Int
  sumTotalChangedLines: Int
  sumTotalNewLines: Int
  sumTotalRemovedLines: Int
  updatedAt: ISO8601DateTime!
}

type Query {
  """
  Returns all analyses that the analyst is allocated
  """
  allocatedAnalyses(page: Int, limit: Int): AnalysisCollection!

  """
  Returns all analyses the user has access
  """
  analyses(page: Int, limit: Int): AnalysisCollection!

  """
  Return the analysis if the user has access
  """
  analysis(id: ID!): Analysis

  """
  Returns all assets the user has access
  """
  assets(id: ID!, page: Int, limit: Int): AssetCollection!

  """
  Returns all notifications the user has access
  """
  notifications(page: Int, limit: Int): NotificationCollection

  """
  Return user profile by email
  """
  portalUserProfile(email: String!): PortalUser

  """
  Return the project if the user has access
  """
  project(id: ID!): Project

  """
  Returns all vulnerabilities the user has access
  """
  vulnerabilities(page: Int, limit: Int): VulnerabilityCollection

  """
  Returns all vulnerabilities templates by company id
  """
  vulnerabilitiesTemplatesByCompanyId(
    id: ID!
    page: Int
    limit: Int
  ): VulnerabilityTemplateCollection!

  """
  Return the vulnerability if the user has access
  """
  vulnerability(id: ID!): Vulnerability

  """
  Returns all web vulnerabilities the user has access
  """
  webVulnerabilities(page: Int, limit: Int): VulnerabilityCollection
}

"""
Autogenerated input type of UpdateActivityStatusToFinish
"""
input UpdateActivityStatusToFinishInput {
  activityId: Int!
  evidence: String
  evidenceArchive: Upload

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
}

"""
Autogenerated return type of UpdateActivityStatusToFinish
"""
type UpdateActivityStatusToFinishPayload {
  activity: Activity

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  errors: [String!]
}

"""
Autogenerated input type of UpdateActivityStatusToNotApply
"""
input UpdateActivityStatusToNotApplyInput {
  activityId: Int!
  justify: String

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
}

"""
Autogenerated return type of UpdateActivityStatusToNotApply
"""
type UpdateActivityStatusToNotApplyPayload {
  activity: Activity

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  errors: [String!]
}

"""
Autogenerated input type of UpdateActivityStatusToRestart
"""
input UpdateActivityStatusToRestartInput {
  activityId: Int!

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
}

"""
Autogenerated return type of UpdateActivityStatusToRestart
"""
type UpdateActivityStatusToRestartPayload {
  activity: Activity

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  errors: [String!]
}

"""
Autogenerated input type of UpdateActivityStatusToStart
"""
input UpdateActivityStatusToStartInput {
  activityId: Int!

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
}

"""
Autogenerated return type of UpdateActivityStatusToStart
"""
type UpdateActivityStatusToStartPayload {
  activity: Activity

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  errors: [String!]
}

scalar Upload

type Vulnerability {
  affectedComponentId: Int
  authorId: Int
  clientImpact: String
  closeComments: Boolean
  codeReviewCode: String
  codeReviewInputData: String
  codeReviewOutputData: String
  codeReviewVector: String
  commitmentAt: ISO8601DateTime
  createdAt: ISO8601DateTime!
  criticity: String
  deployId: Int
  externalVid: String
  failureType: String
  gauntletIssueId: Int
  githubAlertId: String
  id: ID!
  impact: String
  impactResume: String
  invaded: Boolean
  invadedEnvironmentDescription: String
  legacyId: String
  notificationTitle: String
  notificationType: Boolean
  othersHost: String
  othersProtocol: String
  othersSteps: String
  othersVector: String
  probability: String
  projectId: Int
  title: String
  updatedAt: ISO8601DateTime!
  vid: String
  vulnerabilityModelId: Int
  vulnerabilityStatus: String
  webMethod: String
  webParameters: String
  webProtocol: String
  webRequest: String
  webResponse: String
  webSteps: String
  webUrl: String
}

type VulnerabilityCollection {
  collection: [Vulnerability!]!
  metadata: CollectionMetadata!
}

type VulnerabilityTemplate {
  categoryList: String
  createdAt: ISO8601DateTime!
  criticity: String
  deletedAt: ISO8601DateTime
  description: String
  id: ID!
  impact: String
  impactResume: String
  notification: Boolean
  oldId: Int
  patternList: String
  probability: String
  reference: String
  scopeId: Int
  solution: String
  title: String
  updatedAt: ISO8601DateTime!
}

type VulnerabilityTemplateCollection {
  collection: [VulnerabilityTemplate!]!
  metadata: CollectionMetadata!
}
